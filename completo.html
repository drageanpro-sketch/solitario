<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solitario Klondike ULTRA Pro</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-table: #004d26;
            --bg-texture: radial-gradient(circle at 50% 30%, #006430, #003319);
            --card-width: 85px;
            --card-height: 120px;
            --card-radius: 6px;
            --spacing: 15px;
            --gold-accent: #ffd700;
            --ui-bg: rgba(0,0,0,0.8);
        }

        @media (max-width: 600px) {
            :root {
                --card-width: 13.5vw;
                --card-height: 19vw;
                --spacing: 2vw;
            }
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; }

        body {
            margin: 0;
            background: var(--bg-table);
            background-image: var(--bg-texture);
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- HUD --- */
        #hud {
            padding: 0 15px;
            height: 60px;
            background: var(--ui-bg);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .stats-group { display: flex; gap: 15px; }
        .stat { display: flex; flex-direction: column; align-items: center; min-width: 50px; }
        .stat-label { font-size: 9px; text-transform: uppercase; opacity: 0.8; letter-spacing: 1px; color: #aaa; }
        .stat-val { font-size: 16px; font-weight: bold; font-family: 'Roboto Mono', monospace; color: var(--gold-accent); }

        .controls { display: flex; gap: 8px; }
        
        button {
            background: linear-gradient(to bottom, #3a3a3a, #222);
            border: 1px solid #444;
            border-radius: 6px;
            color: #eee;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            display: flex; align-items: center; gap: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        button:hover { background: #444; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }
        
        .btn-green { background: linear-gradient(to bottom, #2ecc71, #27ae60); border-color: #27ae60; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .btn-green:hover { background: linear-gradient(to bottom, #2ecc71, #2ecc71); }
        
        .btn-blue { background: linear-gradient(to bottom, #3498db, #2980b9); border-color: #2980b9; }

        /* --- TOASTS --- */
        .toast-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 10px; z-index: 2000; pointer-events: none;
        }
        .toast {
            background: rgba(0,0,0,0.9);
            color: white; padding: 10px 20px; border-radius: 20px;
            border: 1px solid var(--gold-accent);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            animation: slideUp 0.3s ease-out;
            font-size: 14px; display: flex; align-items: center; gap: 10px;
        }
        @keyframes slideUp { from { opacity:0; transform:translateY(20px); } to { opacity:1; transform:translateY(0); } }

        /* --- GAME BOARD --- */
        #game-board {
            flex: 1; padding: 20px; max-width: 1000px; width: 100%; margin: 0 auto; position: relative;
        }

        .row-top { display: flex; justify-content: space-between; height: var(--card-height); margin-bottom: 25px; }
        .pile-group { display: flex; gap: var(--spacing); }

        .slot {
            width: var(--card-width); height: var(--card-height); border-radius: var(--card-radius);
            border: 2px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2);
            position: relative; display: flex; justify-content: center; align-items: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }

        .slot.foundation::after { content: attr(data-icon); font-size: 40px; opacity: 0.1; font-family: serif; color: white; }
        .slot.refresh-stock { border-color: #2ecc71; cursor: pointer; }
        .slot.refresh-stock::before { content: '↺'; font-size: 30px; color: #2ecc71; }

        /* --- CARDS --- */
        .card {
            width: var(--card-width); height: var(--card-height); border-radius: var(--card-radius);
            background-color: #fff; position: absolute;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 10; overflow: hidden;
            transition: transform 0.1s;
        }

        .card-back {
            width: 100%; height: 100%; background: #fff; padding: 4px; display: none;
        }
        .back-pattern {
            width: 100%; height: 100%; border-radius: 3px; background-color: #c0392b; /* Rojo clásico */
            background-image: 
                repeating-linear-gradient(45deg, rgba(255,255,255,0.1) 0, rgba(255,255,255,0.1) 2px, transparent 2px, transparent 6px);
        }
        .card[data-face="down"] .card-back { display: block; }
        .card[data-face="up"] .card-face { display: flex; }
        .card[data-face="up"] { cursor: grab; }

        .card-face {
            width: 100%; height: 100%; display: none; flex-direction: column; justify-content: space-between; padding: 3px;
        }

        .card[data-color="red"] { color: #d40000; }
        .card[data-color="black"] { color: #1a1a1a; }

        .corner { display: flex; flex-direction: column; align-items: center; width: 20px; line-height: 1; padding-top: 2px; }
        .corner span:first-child { font-family: 'Playfair Display', serif; font-size: 18px; font-weight: bold; letter-spacing: -1px; }
        .corner span:last-child { font-size: 14px; margin-top: -2px; }
        .corner.btm { align-self: flex-end; transform: rotate(180deg); }

        .center-area {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 60%; height: 60%; display: flex; justify-content: center; align-items: center;
        }
        .pip-simple { font-size: 42px; line-height: 1; }
        
        .royal-box {
            width: 100%; height: 100%; border: 1px solid var(--gold-accent);
            display: flex; justify-content: center; align-items: center; position: relative;
            background: linear-gradient(135deg, rgba(255,215,0,0.1), transparent);
        }
        .royal-letter { font-family: 'Playfair Display', serif; font-size: 40px; font-weight: bold; z-index: 2; }
        .royal-suit { position: absolute; font-size: 60px; opacity: 0.15; z-index: 1; }

        .card.dragging { z-index: 9999 !important; box-shadow: 0 15px 30px rgba(0,0,0,0.6); pointer-events: none; transform: scale(1.05); }

        /* Animación Pista */
        .hint-highlight {
            animation: pulseGold 1.5s infinite;
            box-shadow: 0 0 15px var(--gold-accent) !important;
            border: 2px solid var(--gold-accent);
        }
        .dest-highlight {
            box-shadow: inset 0 0 20px var(--gold-accent) !important;
            border-color: var(--gold-accent) !important;
        }
        @keyframes pulseGold {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(255,215,0,0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,215,0,1); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(255,215,0,0); }
        }

        .tableau-col { position: relative; width: var(--card-width); min-height: 150px; }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.85);
            display: none; justify-content: center; align-items: center; z-index: 3000;
        }
        .modal {
            background: #222; color: #fff; padding: 30px; border-radius: 12px;
            text-align: center; border: 1px solid #444; max-width: 350px; width: 90%;
            box-shadow: 0 20px 50px rgba(0,0,0,0.7);
        }
        .modal h2 { margin-top: 0; color: var(--gold-accent); }
        
        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;
        }
        
        /* Switch */
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #555; transition: .4s; border-radius: 24px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #2ecc71; }
        input:checked + .slider:before { transform: translateX(26px); }

    </style>
</head>
<body>

<div id="hud">
    <div class="stats-group">
        <div class="stat">
            <span class="stat-label">Puntos</span>
            <span class="stat-val" id="score">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Tiempo</span>
            <span class="stat-val" id="timer">00:00</span>
        </div>
        <div class="stat">
            <span class="stat-label">Movs</span>
            <span class="stat-val" id="moves">0</span>
        </div>
    </div>
    <div class="controls">
        <button onclick="Game.undo()" title="Deshacer"><i class="fas fa-undo"></i></button>
        <button onclick="Game.showHint()" title="Pista" class="btn-blue"><i class="fas fa-lightbulb"></i></button>
        <button onclick="UI.toggleSettings()"><i class="fas fa-cog"></i></button>
        <button onclick="Game.autoComplete()" id="btn-auto" class="btn-green" style="display:none"><i class="fas fa-magic"></i> Auto</button>
        <button onclick="Game.newGameConfirm()" class="btn-green"><i class="fas fa-plus"></i> Nuevo</button>
    </div>
</div>

<div id="game-board">
    <div class="row-top">
        <div class="pile-group">
            <div id="stock" class="slot" onclick="Game.drawCard()"></div>
            <div id="waste" class="slot"></div>
        </div>
        <div class="pile-group">
            <div id="fnd-0" class="slot foundation" data-icon="♥"></div>
            <div id="fnd-1" class="slot foundation" data-icon="♦"></div>
            <div id="fnd-2" class="slot foundation" data-icon="♣"></div>
            <div id="fnd-3" class="slot foundation" data-icon="♠"></div>
        </div>
    </div>
    <div class="row-top" style="align-items: flex-start; height: auto;">
        <div id="tab-0" class="tableau-col"></div>
        <div id="tab-1" class="tableau-col"></div>
        <div id="tab-2" class="tableau-col"></div>
        <div id="tab-3" class="tableau-col"></div>
        <div id="tab-4" class="tableau-col"></div>
        <div id="tab-5" class="tableau-col"></div>
        <div id="tab-6" class="tableau-col"></div>
    </div>
</div>

<div class="toast-container" id="toast-container"></div>

<!-- Modal Ajustes -->
<div id="settings-modal" class="modal-overlay">
    <div class="modal">
        <h2><i class="fas fa-cog"></i> Configuración</h2>
        
        <div class="setting-row">
            <span><i class="fas fa-volume-up"></i> Sonido</span>
            <label class="switch">
                <input type="checkbox" id="toggle-sound" checked onchange="AudioMgr.toggle(this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        
        <div class="setting-row">
            <span><i class="fas fa-layer-group"></i> Robar 3 Cartas (Difícil)</span>
            <label class="switch">
                <input type="checkbox" id="toggle-draw3" onchange="Game.setDrawMode(this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        
        <div style="margin-top:20px; display:flex; gap:10px;">
            <button onclick="UI.toggleSettings()" style="flex:1; justify-content:center;">Cerrar</button>
            <button onclick="Game.init(); UI.toggleSettings()" class="btn-green" style="flex:1; justify-content:center;">Reiniciar</button>
        </div>
    </div>
</div>

<!-- Modal Victoria -->
<div id="win-modal" class="modal-overlay">
    <div class="modal" style="border-color: var(--gold-accent);">
        <h1 style="color: var(--gold-accent); font-size: 3em; margin: 10px 0;">¡Victoria!</h1>
        <p>¡Has completado el solitario!</p>
        <div style="margin: 20px 0; font-size: 1.2em;">
            <p>Puntuación: <strong id="final-score" style="color:var(--gold-accent)">0</strong></p>
            <p>Tiempo: <strong id="final-time">00:00</strong></p>
        </div>
        <button class="btn-green" style="width:100%; justify-content:center; padding: 12px;" onclick="Game.init()">Jugar Otra Vez</button>
    </div>
</div>

<script>
/**
 * AUDIO MANAGER
 * Usa los sonidos originales de tu primer archivo
 */
const AudioMgr = {
    enabled: true,
    sounds: {
        move: new Audio("https://assets.mixkit.co/sfx/preview/mixkit-card-slide-1538.mp3"),
        flip: new Audio("https://assets.mixkit.co/sfx/preview/mixkit-card-flip-1554.mp3"),
        win: new Audio("https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3"),
        deal: new Audio("https://assets.mixkit.co/sfx/preview/mixkit-card-dealing-1561.mp3"),
        success: new Audio("https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3")
    },
    
    play(name) {
        if (!this.enabled || !this.sounds[name]) return;
        this.sounds[name].currentTime = 0;
        this.sounds[name].play().catch(() => {});
    },
    
    toggle(state) {
        this.enabled = state;
        UI.showToast(state ? "Sonido Activado" : "Sonido Desactivado");
    }
};

/**
 * UI MANAGER
 */
const UI = {
    showToast(msg, icon="info-circle") {
        const container = document.getElementById('toast-container');
        const el = document.createElement('div');
        el.className = 'toast';
        el.innerHTML = `<i class="fas fa-${icon}" style="color:var(--gold-accent)"></i> ${msg}`;
        container.appendChild(el);
        setTimeout(() => el.remove(), 3000);
    },
    
    toggleSettings() {
        const modal = document.getElementById('settings-modal');
        modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
    }
};

/**
 * GAME ENGINE
 */
const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
const SUIT_DATA = { 
    'hearts': { color: 'red', symbol: '♥' }, 
    'diamonds': { color: 'red', symbol: '♦' }, 
    'clubs': { color: 'black', symbol: '♣' }, 
    'spades': { color: 'black', symbol: '♠' } 
};
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

class Card {
    constructor(suit, rank, id) {
        this.suit = suit;
        this.rank = rank;
        this.id = id;
        this.faceUp = false;
        this.value = rank + 1;
        this.color = SUIT_DATA[suit].color;
        this.symbol = SUIT_DATA[suit].symbol;
        this.name = RANKS[rank];
    }

    createDOM() {
        const div = document.createElement('div');
        div.className = 'card';
        div.id = this.id;
        div.dataset.color = this.color;
        div.setAttribute('data-face', this.faceUp ? 'up' : 'down');

        div.innerHTML = `<div class="card-back"><div class="back-pattern"></div></div>`;

        const face = document.createElement('div');
        face.className = 'card-face';
        
        const top = document.createElement('div');
        top.className = 'corner';
        top.innerHTML = `<span>${this.name}</span><span>${this.symbol}</span>`;

        const center = document.createElement('div');
        center.className = 'center-area';
        
        if (this.value > 10) { 
            center.innerHTML = `<div class="royal-box"><span class="royal-letter">${this.name}</span><span class="royal-suit">${this.symbol}</span></div>`;
        } else if (this.value === 1) {
            center.innerHTML = `<span class="pip-simple" style="font-size: 50px">${this.symbol}</span>`;
        } else {
            center.innerHTML = `<span class="pip-simple">${this.symbol}</span>`;
        }

        const btm = top.cloneNode(true);
        btm.className = 'corner btm';

        face.appendChild(top);
        face.appendChild(center);
        face.appendChild(btm);
        div.appendChild(face);

        div.addEventListener('mousedown', (e) => Input.dragStart(e, this));
        div.addEventListener('touchstart', (e) => Input.dragStart(e, this), {passive: false});
        div.addEventListener('dblclick', () => Game.autoMove(this));

        return div;
    }
}

const Game = {
    // Config
    drawThree: false,
    
    // State
    deck: [],
    stock: [], waste: [],
    foundations: [[],[],[],[]],
    tableau: [[],[],[],[],[],[],[]],
    history: [],
    score: 0, moves: 0,
    startTime: null, timerInt: null,

    init() {
        this.reset();
        this.createDeck();
        this.shuffle();
        this.deal();
        this.startTimer();
        this.render();
        
        AudioMgr.play('deal');
        UI.showToast("¡Nueva partida iniciada!", "play");
        document.getElementById('win-modal').style.display = 'none';
        document.getElementById('settings-modal').style.display = 'none';
    },
    
    newGameConfirm() {
        if (this.moves > 0 && confirm("¿Abandonar partida actual y empezar una nueva?")) {
            this.init();
        } else if (this.moves === 0) {
            this.init();
        }
    },
    
    setDrawMode(isThree) {
        this.drawThree = isThree;
        // Solo afecta al siguiente draw, no resetea el juego actual inmediatamente a menos que se quiera
        UI.showToast(`Modo cambiado: Robar ${isThree ? '3' : '1'} carta(s)`);
    },

    reset() {
        this.stock = []; this.waste = [];
        this.foundations = [[],[],[],[]];
        this.tableau = [[],[],[],[],[],[],[]];
        this.history = [];
        this.score = 0; this.moves = 0;
        clearInterval(this.timerInt);
        document.getElementById('timer').innerText = "00:00";
        document.getElementById('btn-auto').style.display = 'none';
    },

    createDeck() {
        this.deck = [];
        let id = 0;
        for (let s of SUITS) {
            for (let r = 0; r < 13; r++) {
                this.deck.push(new Card(s, r, `c-${id++}`));
            }
        }
    },

    shuffle() { this.deck.sort(() => Math.random() - 0.5); },

    deal() {
        let idx = 0;
        for (let i=0; i<7; i++) {
            for (let j=0; j<=i; j++) {
                const c = this.deck[idx++];
                if (j===i) c.faceUp = true;
                this.tableau[i].push(c);
            }
        }
        while(idx < 52) this.stock.push(this.deck[idx++]);
    },

    drawCard() {
        this.pushState();
        AudioMgr.play('flip');
        
        if (this.stock.length === 0) {
            if (this.waste.length === 0) return;
            // Reciclar
            this.stock = this.waste.reverse().map(c => { c.faceUp = false; return c; });
            this.waste = [];
            this.score = Math.max(0, this.score - 100);
            UI.showToast("Mazo reciclado (-100 pts)");
        } else {
            const count = this.drawThree ? Math.min(3, this.stock.length) : 1;
            for(let i=0; i<count; i++) {
                const c = this.stock.pop();
                c.faceUp = true;
                this.waste.push(c);
            }
        }
        this.moves++;
        this.render();
    },

    isValidMove(card, targetPile, type) {
        if (type === 'foundation') {
            if (targetPile.length === 0) return card.value === 1;
            const top = targetPile[targetPile.length-1];
            return top.suit === card.suit && card.value === top.value + 1;
        } 
        if (type === 'tableau') {
            if (targetPile.length === 0) return card.value === 13; 
            const top = targetPile[targetPile.length-1];
            return top.color !== card.color && top.value === card.value + 1;
        }
        return false;
    },

    executeMove(cards, sourcePile, targetPile, type, record=true) {
        if (record) this.pushState();

        const idx = sourcePile.indexOf(cards[0]);
        sourcePile.splice(idx, cards.length);

        // Destapar
        if (sourcePile.length > 0 && this.tableau.includes(sourcePile)) {
            const top = sourcePile[sourcePile.length-1];
            if (!top.faceUp) {
                top.faceUp = true;
                this.score += 5;
                AudioMgr.play('flip');
            }
        }

        cards.forEach(c => targetPile.push(c));
        
        if (type === 'foundation') {
            this.score += 10;
            AudioMgr.play('success');
            UI.showToast(`+10 Puntos (${cards[0].name}${cards[0].symbol})`, "star");
        } else {
            AudioMgr.play('move');
        }
        
        this.moves++;
        this.render();
        this.checkWin();
    },

    autoMove(card) {
        if (!card.faceUp) return;
        const loc = this.locateCard(card);
        if (!loc || loc.pile[loc.pile.length-1] !== card) return;

        for (let i=0; i<4; i++) {
            if (this.isValidMove(card, this.foundations[i], 'foundation')) {
                this.executeMove([card], loc.pile, this.foundations[i], 'foundation');
                return;
            }
        }
    },

    locateCard(card) {
        if (this.waste.includes(card)) return { pile: this.waste };
        for (let t of this.tableau) if (t.includes(card)) return { pile: t };
        for (let f of this.foundations) if (f.includes(card)) return { pile: f };
        return null;
    },

    showHint() {
        // Limpiar highlights previos
        document.querySelectorAll('.hint-highlight').forEach(el => el.classList.remove('hint-highlight'));

        const check = (card, sourcePile) => {
            // Check Foundation
            for(let i=0; i<4; i++) {
                if(this.isValidMove(card, this.foundations[i], 'foundation')) {
                    this.highlight(card.id, `fnd-${i}`);
                    return true;
                }
            }
            // Check Tableau
            if (this.tableau.includes(sourcePile) && sourcePile.indexOf(card) > 0) return false;
            for(let i=0; i<7; i++) {
                const t = this.tableau[i];
                if(t !== sourcePile && this.isValidMove(card, t, 'tableau')) {
                    this.highlight(card.id, `tab-${i}`);
                    return true;
                }
            }
            return false;
        };

        // 1. Waste
        if (this.waste.length > 0) {
            if (check(this.waste[this.waste.length-1], this.waste)) return;
        }
        // 2. Tableau
        for(let t of this.tableau) {
            if (t.length > 0) {
                // Check all faceup cards? No, just visible sequences ideally, but checking top is safer for hints
                // Check deep cards too
                for (let c of t) {
                    if (c.faceUp && check(c, t)) return;
                }
            }
        }
        
        UI.showToast("No hay movimientos disponibles", "exclamation-circle");
        AudioMgr.play('error'); // Sonido de error si no hay hint
    },

    highlight(cardId, destId) {
        const el = document.getElementById(cardId);
        const dest = document.getElementById(destId);
        if(el) el.classList.add('hint-highlight');
        if(dest) {
             dest.classList.add('hint-highlight'); 
             setTimeout(() => dest.classList.remove('hint-highlight'), 1500);
        }
        setTimeout(() => el.classList.remove('hint-highlight'), 1500);
        
        UI.showToast("¡Pista encontrada! (-2 pts)");
        this.score = Math.max(0, this.score - 2);
        this.render();
    },

    checkWin() {
        const stockEmpty = this.stock.length === 0;
        let allFaceUp = true;
        this.tableau.forEach(col => col.forEach(c => { if(!c.faceUp) allFaceUp = false; }));
        
        if (stockEmpty && allFaceUp) {
            document.getElementById('btn-auto').style.display = 'flex';
        }

        let totalFnd = 0;
        this.foundations.forEach(f => totalFnd += f.length);
        if (totalFnd === 52) {
            clearInterval(this.timerInt);
            document.getElementById('final-score').innerText = this.score;
            document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
            document.getElementById('win-modal').style.display = 'flex';
            AudioMgr.play('win');
        }
    },

    autoComplete() {
        UI.showToast("Auto-completando...", "magic");
        const interval = setInterval(() => {
            let moved = false;
            for (let col of this.tableau) {
                if (col.length > 0) {
                    const c = col[col.length-1];
                    for (let f of this.foundations) {
                        if (this.isValidMove(c, f, 'foundation')) {
                            this.executeMove([c], col, f, 'foundation', false);
                            moved = true;
                            break;
                        }
                    }
                }
                if (moved) break;
            }
            if (!moved && this.waste.length > 0) {
                const c = this.waste[this.waste.length-1];
                for (let f of this.foundations) {
                    if (this.isValidMove(c, f, 'foundation')) {
                        this.executeMove([c], this.waste, f, 'foundation', false);
                        moved = true;
                        break;
                    }
                }
            }
            if (!moved) clearInterval(interval);
        }, 100);
    },

    pushState() {
        const state = JSON.stringify({
            stock: this.stock.map(this.serialize),
            waste: this.waste.map(this.serialize),
            foundations: this.foundations.map(p => p.map(this.serialize)),
            tableau: this.tableau.map(p => p.map(this.serialize)),
            score: this.score, moves: this.moves
        });
        this.history.push(state);
        if (this.history.length > 20) this.history.shift();
    },
    
    serialize(c) { return {s:c.suit, r:c.rank, f:c.faceUp, id:c.id}; },
    
    undo() {
        if (this.history.length === 0) {
            UI.showToast("No hay más movimientos");
            return;
        }
        const prev = JSON.parse(this.history.pop());
        const restore = (d) => { const c = new Card(d.s, d.r, d.id); c.faceUp = d.f; return c; };
        
        this.stock = prev.stock.map(restore);
        this.waste = prev.waste.map(restore);
        this.foundations = prev.foundations.map(p => p.map(restore));
        this.tableau = prev.tableau.map(p => p.map(restore));
        this.score = prev.score;
        this.moves = prev.moves;
        this.render();
        UI.showToast("Deshacer");
    },

    render() {
        document.getElementById('score').innerText = this.score;
        document.getElementById('moves').innerText = this.moves;

        const elStock = document.getElementById('stock');
        elStock.innerHTML = '';
        elStock.className = this.stock.length === 0 ? 'slot refresh-stock' : 'slot';
        if (this.stock.length > 0) {
            const c = document.createElement('div');
            c.className = 'card';
            c.innerHTML = '<div class="card-back" style="display:block"><div class="back-pattern"></div></div>';
            elStock.appendChild(c);
        }

        const elWaste = document.getElementById('waste');
        elWaste.innerHTML = '';
        if (this.waste.length > 0) {
            // Mostrar las últimas 3 cartas en abanico
            const count = 3;
            const startIndex = Math.max(0, this.waste.length - count);
            const visibleCards = this.waste.slice(startIndex);
            
            visibleCards.forEach((c, i) => {
                const dom = c.createDOM();
                // Desplazamiento horizontal de 20px para crear el abanico
                dom.style.left = (i * 20) + 'px';
                // Asegurar que estén alineadas verticalmente
                dom.style.top = '0px';
                elWaste.appendChild(dom);
            });
        }

        for(let i=0; i<4; i++) {
            const el = document.getElementById(`fnd-${i}`);
            while(el.firstChild) el.firstChild.remove();
            if (this.foundations[i].length > 0) {
                const c = this.foundations[i][this.foundations[i].length-1];
                const cardDom = c.createDOM();
                cardDom.style.top = '0';
                el.appendChild(cardDom);
            }
        }

        for(let i=0; i<7; i++) {
            const el = document.getElementById(`tab-${i}`);
            el.innerHTML = '';
            this.tableau[i].forEach((c, idx) => {
                const dom = c.createDOM();
                dom.style.top = (idx * 30) + 'px';
                el.appendChild(dom);
            });
        }
    },

    startTimer() {
        this.startTime = Date.now();
        this.timerInt = setInterval(() => {
            const diff = Math.floor((Date.now() - this.startTime)/1000);
            const m = Math.floor(diff/60).toString().padStart(2,'0');
            const s = (diff%60).toString().padStart(2,'0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);
    }
};

const Input = {
    data: null,

    dragStart(e, card) {
        if (!card.faceUp) return;
        if (e.button !== 0 && e.type !== 'touchstart') return;
        e.preventDefault();

        const loc = Game.locateCard(card);
        if (!loc) return;
        
        if (!Game.tableau.includes(loc.pile) && loc.pile[loc.pile.length-1] !== card) return;

        const idx = loc.pile.indexOf(card);
        const cardsToDrag = loc.pile.slice(idx);
        
        const cx = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const cy = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        const rect = document.getElementById(card.id).getBoundingClientRect();
        
        this.data = {
            cards: cardsToDrag,
            sourcePile: loc.pile,
            ghosts: []
        };
        
        cardsToDrag.forEach((c, i) => {
            const realEl = document.getElementById(c.id);
            const ghost = realEl.cloneNode(true);
            const realRect = realEl.getBoundingClientRect();
            
            ghost.classList.add('dragging');
            ghost.style.position = 'fixed';
            ghost.style.left = realRect.left + 'px';
            ghost.style.top = realRect.top + 'px';
            ghost.style.width = 'var(--card-width)';
            
            ghost.dataset.dx = realRect.left - cx;
            ghost.dataset.dy = realRect.top - cy;

            document.body.appendChild(ghost);
            this.data.ghosts.push(ghost);
            realEl.style.opacity = 0;
        });

        document.addEventListener('mousemove', this.dragMove);
        document.addEventListener('mouseup', this.dragEnd);
        document.addEventListener('touchmove', this.dragMove, {passive:false});
        document.addEventListener('touchend', this.dragEnd);
    },

    dragMove: (e) => {
        if (!Input.data) return;
        e.preventDefault();
        const cx = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const cy = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

        Input.data.ghosts.forEach(g => {
            const dx = parseFloat(g.dataset.dx);
            const dy = parseFloat(g.dataset.dy);
            g.style.left = (cx + dx) + 'px';
            g.style.top = (cy + dy) + 'px';
        });
    },

    dragEnd: (e) => {
        if (!Input.data) return;
        
        const cx = e.type.includes('touch') ? e.changedTouches[0].clientX : e.clientX;
        const cy = e.type.includes('touch') ? e.changedTouches[0].clientY : e.clientY;

        Input.data.ghosts.forEach(g => g.style.display = 'none');
        const hitEl = document.elementFromPoint(cx, cy);
        Input.data.ghosts.forEach(g => g.style.display = 'block');
        
        let valid = false;
        
        if (hitEl) {
            const fSlot = hitEl.closest('.foundation');
            if (fSlot && Input.data.cards.length === 1) {
                const idx = parseInt(fSlot.id.split('-')[1]);
                const pile = Game.foundations[idx];
                if (Game.isValidMove(Input.data.cards[0], pile, 'foundation')) {
                    Game.executeMove(Input.data.cards, Input.data.sourcePile, pile, 'foundation');
                    valid = true;
                }
            }
            const tSlot = hitEl.closest('.tableau-col');
            if (tSlot) {
                const idx = parseInt(tSlot.id.split('-')[1]);
                const pile = Game.tableau[idx];
                if (Game.isValidMove(Input.data.cards[0], pile, 'tableau')) {
                    Game.executeMove(Input.data.cards, Input.data.sourcePile, pile, 'tableau');
                    valid = true;
                }
            }
        }

        Input.data.ghosts.forEach(g => g.remove());
        Input.data.cards.forEach(c => {
            const el = document.getElementById(c.id);
            if(el) el.style.opacity = 1;
        });

        Input.data = null;
        document.removeEventListener('mousemove', Input.dragMove);
        document.removeEventListener('mouseup', Input.dragEnd);
        document.removeEventListener('touchmove', Input.dragMove);
        document.removeEventListener('touchend', Input.dragEnd);
    }
};

Input.dragMove = Input.dragMove.bind(Input);
Input.dragEnd = Input.dragEnd.bind(Input);

Game.init();
</script>
</body>
</html>
